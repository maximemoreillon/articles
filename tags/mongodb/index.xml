<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>MongoDB on Maxime Moreillon</title>
    <link>https://articles.maximemoreillon.com/tags/mongodb/</link>
    <description>Recent content in MongoDB on Maxime Moreillon</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Mon, 19 Dec 2022 00:00:00 +0000</lastBuildDate><atom:link href="https://articles.maximemoreillon.com/tags/mongodb/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Mongoose query documents with matching array element</title>
      <link>https://articles.maximemoreillon.com/articles/adb7dbb3-cc17-4dd2-b8c0-1fe5f46e62de/</link>
      <pubDate>Mon, 19 Dec 2022 00:00:00 +0000</pubDate>
      
      <guid>https://articles.maximemoreillon.com/articles/adb7dbb3-cc17-4dd2-b8c0-1fe5f46e62de/</guid>
      
      <description>&lt;p&gt;As a NoSQL database, MongoDB can store arrays as fields of a document. This article presents how to query such documents by filtering those with arrays that contain a specific value.&lt;/p&gt;
&lt;p&gt;Let&amp;rsquo;s imagine a collection containing the following movie records:&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;[
  {
    title: &amp;#39;Inception&amp;#39;,
    actors: [
      &amp;#39;Tom Hardy&amp;#39;
      &amp;#39;Leonardo DiCaprio&amp;#39;
    ]
  },
  {
    title: &amp;#39;The Dark Knight Rises&amp;#39;,
    actors: [
      &amp;#39;Tom Hardy&amp;#39;,
      &amp;#39;Christian Bale&amp;#39;,
    ]
  },
  {
    title: &amp;#39;The Dark Knight&amp;#39;,
    actors: [
      &amp;#39;Christian Bale&amp;#39;,
      &amp;#39;Heath Ledger&amp;#39;
    ]
  },	
]
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;There would be cases where one would want to query all movies in which a specific actor starred.&lt;/p&gt;</description>
      
    </item>
    
    <item>
      <title>MQTT Logger</title>
      <link>https://articles.maximemoreillon.com/articles/5aa92bbf-956c-43a9-8f3c-e0bdacd6412d/</link>
      <pubDate>Sat, 09 Jul 2022 00:00:00 +0000</pubDate>
      
      <guid>https://articles.maximemoreillon.com/articles/5aa92bbf-956c-43a9-8f3c-e0bdacd6412d/</guid>
      
      <description>&lt;p&gt;Over the years, I&amp;rsquo;ve used various IoT sensors which collect data that is then broadcast using MQTT. Those sensors generally broadcast individual measurements without saving any form of history locally. Consequently, if one would want to plot time-series graphs, the data would first need to be stored somewhere. This is the objective of the application presented in this article, named MQTT Logger.&lt;/p&gt;
&lt;p&gt;MQTT Logger is a Node.js application which subscribes to MQTT topics of IoT sensors and stores the data that those published in an InfluxDB time-series database.&lt;/p&gt;</description>
      
    </item>
    
    <item>
      <title>Wardrobe and outfits management web app</title>
      <link>https://articles.maximemoreillon.com/articles/0c1a7a47-c651-472d-a867-e1e2b040e997/</link>
      <pubDate>Thu, 27 Jan 2022 00:00:00 +0000</pubDate>
      
      <guid>https://articles.maximemoreillon.com/articles/0c1a7a47-c651-472d-a867-e1e2b040e997/</guid>
      
      <description>&lt;p&gt;Have you ever bought a piece of clothing only to come home and realize you already had a similar one in your wardrobe? This web application aims at solving this problem by allowing users to register their garments in a database.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://img.maximemoreillon.com/images/61f2b47035a52f9bb09e4eef&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;Moreover, the application provides a way to register complete outfits and list the various garments that are parts it.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://img.maximemoreillon.com/images/62b8fa733bbcba1c3e77be8c&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;The application consists of a Node.js back-end which stores garment information in a MongoDB database. It also provides a REST API built using Express to exchange data with the application&amp;rsquo;s GUI. The latter is a Vue.js single page application featuring UI components from the Vuetify library.&lt;/p&gt;</description>
      
    </item>
    
    <item>
      <title>Food manager</title>
      <link>https://articles.maximemoreillon.com/articles/573/</link>
      <pubDate>Tue, 02 Nov 2021 00:00:00 +0000</pubDate>
      
      <guid>https://articles.maximemoreillon.com/articles/573/</guid>
      
      <description>&lt;p&gt;The other day, I found myself putting on some weight. This rather surprised me as I thought I was having a healthy diet and exercised almost daily. To identify the root of the problem, I decided to start measuring my calorie intake as well as the macronutrients that constitute said intake.&lt;/p&gt;
&lt;p&gt;To achieve this, I built a simple web application using the MEVN stack. The application serves two purposes:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Store information about the various food I eat&lt;/li&gt;
&lt;li&gt;Compute the total calorie count and macronutrients constitution of a given list of food&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;food-database&#34;&gt;Food database&lt;/h2&gt;
&lt;p&gt;In order to compute a calorie count or macronutrient constitution of a meal, one must first know those values for each individual piece of food in it. This information is stored in a MongoDB collection, managed by its own model, controllers, routes and view.&lt;/p&gt;</description>
      
    </item>
    
    <item>
      <title>Camera viewer</title>
      <link>https://articles.maximemoreillon.com/articles/519/</link>
      <pubDate>Mon, 20 Sep 2021 00:00:00 +0000</pubDate>
      
      <guid>https://articles.maximemoreillon.com/articles/519/</guid>
      
      <description>&lt;p&gt;IP cameras are cheaper than ever and with the ESP32-CAM boards it is now possible to stream video for less than USD 10. However, IP cameras are commonly either only accessible from within their network, or use servers from third party companies to allow users to see the video feed from anywhere in the world. As both scenarios are inconvenient, I decided to create a camera viewer application that can proxy the video feed to a web interface.&lt;/p&gt;</description>
      
    </item>
    
    <item>
      <title>User management and authentication service using MongoDB</title>
      <link>https://articles.maximemoreillon.com/articles/495/</link>
      <pubDate>Mon, 20 Sep 2021 00:00:00 +0000</pubDate>
      
      <guid>https://articles.maximemoreillon.com/articles/495/</guid>
      
      <description>&lt;p&gt;More often than not, web applications require restrictions regarding who can access the content that they serve. This involves an user management and authentication system, which, if designed inappropriately, can lead to security concerns. However, the development of such system can be time consuming, especially if done repeatedly for multiple applications.&lt;/p&gt;
&lt;p&gt;To solve this problem, this article presents a user management and authentication service, built around MongoDB, that can be easily plugged into an existing application with only minimal refactoring.&lt;/p&gt;</description>
      
    </item>
    
    <item>
      <title>MongoDB K8s manifest</title>
      <link>https://articles.maximemoreillon.com/articles/503/</link>
      <pubDate>Wed, 31 Mar 2021 00:00:00 +0000</pubDate>
      
      <guid>https://articles.maximemoreillon.com/articles/503/</guid>
      
      <description>&lt;p&gt;Here&amp;rsquo;s a simple manifest to deploy MongoDB with data persistence in microk8s:&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;apiVersion: v1
kind: PersistentVolumeClaim
metadata:
  name: mongo
  namespace: my-namespace
spec:
  accessModes:
    - ReadWriteOnce
  resources:
    requests:
      storage: 100Gi
---
apiVersion: apps/v1
kind: Deployment
metadata:
  name: mongo
  namespace: my-namespace
spec:
  replicas: 1
  selector:
    matchLabels:
      app: mongo
  template:
    metadata:
      labels:
        app: mongo
    spec:
      containers:
      - name: mongo
        image: mongo
        imagePullPolicy: Always
        ports:
        - containerPort: 27017
        volumeMounts:
        - mountPath: &amp;#34;/data/db&amp;#34;
          name: mongo
      volumes:
      - name: mongo
        persistentVolumeClaim:
          claimName: mongo
---
apiVersion: v1
kind: Service
metadata:
  name: mongo
  namespace: my-namespace
spec:
  ports:
  - port: 27017
  selector:
    app: mongo
  type: ClusterIP
&lt;/code&gt;&lt;/pre&gt;</description>
      
    </item>
    
    <item>
      <title>Fixed asset management system</title>
      <link>https://articles.maximemoreillon.com/articles/87/</link>
      <pubDate>Mon, 23 Mar 2020 00:00:00 +0000</pubDate>
      
      <guid>https://articles.maximemoreillon.com/articles/87/</guid>
      
      <description>&lt;p&gt;Many companies rely on spreadsheets to keep track of their fixed assets. However, spreadsheets are commonly designed to be edited manually, which makes automation difficult.&lt;/p&gt;
&lt;p&gt;The application presented in this article is a fixed asset management system based on a MongoDB database, and provides a REST API which makes it possible for other applications or devices to perform CRUD operations on the data, hence greatly improving the automation potential.&lt;/p&gt;
&lt;p&gt;The application uses the MEVN ( MongoDB, Express, Vue.js, Node.js ) stack and thus offers a browser-based GUI.&lt;/p&gt;</description>
      
    </item>
    
    <item>
      <title>Image upload microservice</title>
      <link>https://articles.maximemoreillon.com/articles/43/</link>
      <pubDate>Mon, 23 Mar 2020 00:00:00 +0000</pubDate>
      
      <guid>https://articles.maximemoreillon.com/articles/43/</guid>
      
      <description>&lt;p&gt;An image is worth a thousand words and probably even more if comparing their size in bytes. When designing my CMS, I originally intended to store images directly in the article, encoded in Base64. However, this would considerably increase the size of each article, making the whole CMS slow.&lt;/p&gt;
&lt;p&gt;Ideally images would be loaded independently from articles, which requires them to be served separately. Consequently, I created a simple image management microservice that allows to upload images through a web interface and serves them wherever required.&lt;/p&gt;</description>
      
    </item>
    
    <item>
      <title>Cashless payment system</title>
      <link>https://articles.maximemoreillon.com/articles/133/</link>
      <pubDate>Fri, 20 Mar 2020 00:00:00 +0000</pubDate>
      
      <guid>https://articles.maximemoreillon.com/articles/133/</guid>
      
      <description>&lt;p&gt;A company I worked for had a coffee machine for which employees could purchase coffee. However, the payment was done by putting coins in a jar.&lt;/p&gt;
&lt;p&gt;Not only did this present the obvious risk of theft, this system was also impractical for people not carrying spare change at all time. I decided to solve this issue by designing this cashless payment system.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://img.maximemoreillon.com/image?id=5e796ef4ad3848218cf8697e&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;Here is a video of the system in action:&lt;/p&gt;</description>
      
    </item>
    
    <item>
      <title>Finances management web app</title>
      <link>https://articles.maximemoreillon.com/articles/165/</link>
      <pubDate>Tue, 10 Mar 2020 00:00:00 +0000</pubDate>
      
      <guid>https://articles.maximemoreillon.com/articles/165/</guid>
      
      <description>&lt;p&gt;Most banks nowadays provide e-banking interfaces that allow clients to monitor the state of their accounts. However, each bank has its own system and the provided interfaces sometimes lack functionalities. Consequently, I decided to create my own finance dashboard, that combines information regarding multiple accounts. Currently I use it to keep track of my bank accounts balance over time as well as provide a breakdown of my transactions.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://img.maximemoreillon.com/images/60b1cf1043b282317cabca3b&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;The back-end of the application is built using NodeJS while data is stored in a MongoDB collection for transactions and InfluxDB for the balance history. On the other hand, the front end is built using VueJS and uses ChartsJS for plots.&lt;/p&gt;</description>
      
    </item>
    
    <item>
      <title>Smart home control panel (SHCP)</title>
      <link>https://articles.maximemoreillon.com/articles/154/</link>
      <pubDate>Tue, 10 Mar 2020 00:00:00 +0000</pubDate>
      
      <guid>https://articles.maximemoreillon.com/articles/154/</guid>
      
      <description>&lt;p&gt;I&amp;rsquo;ve been using &lt;a href=&#34;https://www.home-assistant.io/&#34;&gt;Home Assistant&lt;/a&gt; to control my home IoT devices for a while. Although it fulfills all my needs, I wanted to make my own system so as to get a fully customized smart home control panel and learn how to build such an application in the process.&lt;/p&gt;
&lt;p&gt;A simple way to build such an app would be to open the port corresponding to MQTT on my router and make an UI in JavaScript with an MQTT client-side library to communicate with the devices directly. However, for security reasons, I prefer to open only web-related ports to the public. Moreover, my MQTT traffic is currently unencrypted so it would not be wise to use it on a public network. Ideally, I would like to keep all MQTT communication internally with the MQTT port closed on my router, communicating via encrypted TCP traffic. For this purpose, I built a &lt;a href=&#34;https://nodejs.org/&#34;&gt;Node.js&lt;/a&gt; app that interacts with the outside world through HTTPS and then communicates with IoT devices internally.&lt;/p&gt;</description>
      
    </item>
    
    <item>
      <title>Mongoose bulk update upsert</title>
      <link>https://articles.maximemoreillon.com/articles/304/</link>
      <pubDate>Sat, 01 Feb 2020 00:00:00 +0000</pubDate>
      
      <guid>https://articles.maximemoreillon.com/articles/304/</guid>
      
      <description>&lt;p&gt;MongoDB&amp;rsquo;s upsert option enables the creation of a new document if the query of an update operationdoesn&amp;rsquo;t match any existing document. Basically, an update command with upsert creates a document if it does notexist already, and update it otherwise.&lt;/p&gt;
&lt;p&gt;This operation is rather striaghtforward when updating single documents but can be trickier when applied to multiple documents at conce. For multiple documents, bulkWrite can be used:&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;let bulk_operations = []

for (var transaction of req.body.transactions) {
  bulk_operations.push({
    updateOne: {
      filter: transaction,
      update: transaction,
      upsert: true
    }
  })
}

Transaction.bulkWrite(bulk_operations)
.then( bulkWriteOpResult =&amp;gt; {
  console.log(&amp;#39;BULK update OK&amp;#39;);
})
.catch( err =&amp;gt; {
  console.log(err);
});
&lt;/code&gt;&lt;/pre&gt;</description>
      
    </item>
    
    <item>
      <title>Mongoose bulkWrite upsert</title>
      <link>https://articles.maximemoreillon.com/articles/287/</link>
      <pubDate>Sun, 26 Jan 2020 00:00:00 +0000</pubDate>
      
      <guid>https://articles.maximemoreillon.com/articles/287/</guid>
      
      <description>&lt;p&gt;Here is a code snippet for a bulk update with upsert using Mongoose:&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;let bulk_operations = []
  for (var transaction of req.body.transactions) {
    bulk_operations.push({
      updateOne: {
        filter: transaction,
        update: transaction,
        upsert: true
      }
    })
  }

  Transaction.bulkWrite(bulk_operations)
  .then( bulkWriteOpResult =&amp;gt; {
    console.log(&amp;#39;BULK update OK&amp;#39;);
    res.send(&amp;#39;OK&amp;#39;)
  })
  .catch( err =&amp;gt; {
    console.log(&amp;#39;BULK update error&amp;#39;);
    res.status(500)
  });
&lt;/code&gt;&lt;/pre&gt;</description>
      
    </item>
    
  </channel>
</rss>
