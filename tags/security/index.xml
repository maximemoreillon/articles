<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Security on Maxime Moreillon</title>
    <link>https://articles.maximemoreillon.com/tags/security/</link>
    <description>Recent content in Security on Maxime Moreillon</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Sun, 28 Aug 2022 00:00:00 +0000</lastBuildDate><atom:link href="https://articles.maximemoreillon.com/tags/security/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>SSH keys</title>
      <link>https://articles.maximemoreillon.com/articles/83930a48-3f2c-4292-a3c3-5fd0eb266065/</link>
      <pubDate>Sun, 28 Aug 2022 00:00:00 +0000</pubDate>
      
      <guid>https://articles.maximemoreillon.com/articles/83930a48-3f2c-4292-a3c3-5fd0eb266065/</guid>
      
      <description>&lt;p&gt;Using a key file can greatly increase security when connecting to a host via SSH. This article presents how to create such keys and configure hosts to use them.&lt;/p&gt;
&lt;p&gt;First, a SSH key can be created on a local host using the ssh-keygen command:&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;ssh-keygen
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;ssh-keygen will prompt the user for a filename as well as an optional password for the keys. In this example, let&amp;rsquo;s assume that the chosen filename was myKey.&lt;/p&gt;</description>
      
    </item>
    
    <item>
      <title>A template for Vue.js applications</title>
      <link>https://articles.maximemoreillon.com/articles/28/</link>
      <pubDate>Mon, 27 Sep 2021 00:00:00 +0000</pubDate>
      
      <guid>https://articles.maximemoreillon.com/articles/28/</guid>
      
      <description>&lt;p&gt;Over the years, I have built multiple Vue.js applications. Although their business logic differs, those applications often share similar components such as a navigation panel, a header with my logo and an authentication mechanism. Writing those from scratch for each application would be time consuming so I designed an application template that can be installed using &lt;a href=&#34;https://www.npmjs.com/package/@moreillon/vue_application_template&#34;&gt;NPM&lt;/a&gt; to bootstrap my projects.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://img.maximemoreillon.com/images/615255af9a075f4e3559ce34&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;The template integrates in existing Vue.js applications as a component. By default, it wraps the router-view component and adds the following UI components to the app:&lt;/p&gt;</description>
      
    </item>
    
    <item>
      <title>User management microservice based on Neo4J</title>
      <link>https://articles.maximemoreillon.com/articles/585/</link>
      <pubDate>Sat, 25 Sep 2021 00:00:00 +0000</pubDate>
      
      <guid>https://articles.maximemoreillon.com/articles/585/</guid>
      
      <description>&lt;p&gt;Web applications commonly require a user database and the management logic for it. Having to build such software infrastructure for each individual app would be time consuming so I designed a general-purpose user management microservice that can be easily integrated in a project.&lt;/p&gt;
&lt;p&gt;At its core, the service consists of a Node.js + Express API which stores and manages users as nodes in a Neo4J database. here, Neo4J was chosen so that other apps could add their own nodes to it and thus benefit from the advantages of a graph database.&lt;/p&gt;</description>
      
    </item>
    
    <item>
      <title>Multi-user MQTT platform</title>
      <link>https://articles.maximemoreillon.com/articles/485/</link>
      <pubDate>Mon, 20 Sep 2021 00:00:00 +0000</pubDate>
      
      <guid>https://articles.maximemoreillon.com/articles/485/</guid>
      
      <description>&lt;p&gt;Mosquitto is usually the first candidate to come to mind when looking for an MQTT broker. However, by default, Mosquitto manages users using a password file. This makes it difficult to easily add or remove users, especially when the broker is deployed in Kubernetes.&lt;/p&gt;
&lt;p&gt;I recently stumbled upon the &lt;a href=&#34;https://github.com/iegomez/mosquitto-go-auth&#34;&gt;mosquitto-go-auth plugin&lt;/a&gt;, which allows for the authentication to be performed by an external service, by connecting to the latter via, for example, HTTP requests.&lt;/p&gt;</description>
      
    </item>
    
    <item>
      <title>User management and authentication service using MongoDB</title>
      <link>https://articles.maximemoreillon.com/articles/495/</link>
      <pubDate>Mon, 20 Sep 2021 00:00:00 +0000</pubDate>
      
      <guid>https://articles.maximemoreillon.com/articles/495/</guid>
      
      <description>&lt;p&gt;More often than not, web applications require restrictions regarding who can access the content that they serve. This involves an user management and authentication system, which, if designed inappropriately, can lead to security concerns. However, the development of such system can be time consuming, especially if done repeatedly for multiple applications.&lt;/p&gt;
&lt;p&gt;To solve this problem, this article presents a user management and authentication service, built around MongoDB, that can be easily plugged into an existing application with only minimal refactoring.&lt;/p&gt;</description>
      
    </item>
    
    <item>
      <title>Encrypting Mosquitto using Certbot</title>
      <link>https://articles.maximemoreillon.com/articles/497/</link>
      <pubDate>Sat, 28 Nov 2020 00:00:00 +0000</pubDate>
      
      <guid>https://articles.maximemoreillon.com/articles/497/</guid>
      
      <description>&lt;p&gt;The Mosquitto server must be configured using the /etc/mosquitto/conf.d/main.conf file, inside which the path to SSL certificates must be specified. A good topic on the matter can be found &lt;a href=&#34;https://www.digitalocean.com/community/tutorials/how-to-install-and-secure-the-mosquitto-mqtt-messaging-broker-on-ubuntu-18-04-quickstart&#34;&gt;here&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Certificates can be retrieved using Certbot, but for configurations where a microk8s instance is running with the NGINX Ingress controller, A special access for Certbot to fulfill its challenges is required.&lt;/p&gt;
&lt;p&gt;To do so, one can create a endpoint with a port on which certbot will listen, alongside a service and Ingress for it:&lt;/p&gt;</description>
      
    </item>
    
    <item>
      <title>Securing an ingress with basic auth</title>
      <link>https://articles.maximemoreillon.com/articles/374/</link>
      <pubDate>Mon, 20 Apr 2020 00:00:00 +0000</pubDate>
      
      <guid>https://articles.maximemoreillon.com/articles/374/</guid>
      
      <description>&lt;p&gt;This article describes how to use basic auth to protect an ingress in Kuberentes. It it &lt;a href=&#34;https://kubernetes.github.io/ingress-nginx/examples/auth/basic/&#34;&gt;based on this page&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;To protect an ingress using basic auth, a secret must be created. The data of this secret can be generated using htpasswd:&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;htpasswd -c auth myUsername
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Where &lt;code&gt;myUsername&lt;/code&gt; is to be replaced by whatever you want. This creates a filed called &lt;code&gt;auth&lt;/code&gt; in the working directory&lt;/p&gt;
&lt;p&gt;Kubectl provides a convenient command to automatically turn the content of the auth file into a secret:&lt;/p&gt;</description>
      
    </item>
    
    <item>
      <title>Express authorization middleware</title>
      <link>https://articles.maximemoreillon.com/articles/247/</link>
      <pubDate>Mon, 16 Mar 2020 00:00:00 +0000</pubDate>
      
      <guid>https://articles.maximemoreillon.com/articles/247/</guid>
      
      <description>&lt;p&gt;Many applications require some form of authorization mechanism to prevent users from accessing restricted content. Authenticated users are commonly in possession of a cookie containing identification data. With the authentication microservice that I designed, this cookie contains a JWT that contains the user&amp;rsquo;s username. This JWT is sent in the authorization header of HTTP requests. Thus, authorization can be performed easily within each application by simply decoding the JWT. To do so, I designed this simple middleware for ExpressJS.&lt;/p&gt;</description>
      
    </item>
    
    <item>
      <title>Cookies</title>
      <link>https://articles.maximemoreillon.com/articles/286/</link>
      <pubDate>Thu, 13 Feb 2020 00:00:00 +0000</pubDate>
      
      <guid>https://articles.maximemoreillon.com/articles/286/</guid>
      
      <description>&lt;p&gt;Cookies are key-value pairs stored on a web browser. They can be set (i.e. created) using client-side JavaScript. Conversely, a server can get a client&amp;rsquo;s browser to set cookies via instructions in an HTTP response. As such, cookies can be set by both the client and the server.&lt;/p&gt;
&lt;p&gt;Once a cookie is set, it is sent with every subsequent HTTP request addressed at the domain on which the cookie was set. Hence, if a cookie is set while using an application served on the domain example.com, it will not be sent to a server at otherdomain.com. However, cookies can be shared across subdomains. With the previous example, cookies will be sent to exampleapp.example.com.&lt;/p&gt;</description>
      
    </item>
    
    <item>
      <title>Cookie-session</title>
      <link>https://articles.maximemoreillon.com/articles/283/</link>
      <pubDate>Wed, 12 Feb 2020 00:00:00 +0000</pubDate>
      
      <guid>https://articles.maximemoreillon.com/articles/283/</guid>
      
      <description>&lt;p&gt;User authenticates using username and password, server sets a signed cookie containing serialized user info&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;app.use(cookieSession({
  name: &amp;#39;session&amp;#39;,
  secret: &amp;#39;shhhh&amp;#39;,
  maxAge: 253402300000000, // infinite
  sameSite: false,
  domain: &amp;#34;yourdomain.com&amp;#34;
}));
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;key-value pairs can be set using the session property:&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;req.session.username = &amp;#34;myUsername&amp;#34;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;The value is encrypted using the secret defined hereabove&lt;/p&gt;
&lt;p&gt;Requires special options for CORS:&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;app.use(cors({
  origin: [/* origins */],
  credentials: true,
}));
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;As well as Axios:&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;axios.defaults.withCredentials = true
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;This method works well for clients using web browsers with cookies enabled but consequently not so much for mobile or IoT devices&lt;/p&gt;</description>
      
    </item>
    
  </channel>
</rss>
