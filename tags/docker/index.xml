<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Docker on Maxime Moreillon</title>
    <link>https://articles.maximemoreillon.com/tags/docker/</link>
    <description>Recent content in Docker on Maxime Moreillon</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Mon, 20 Sep 2021 00:00:00 +0000</lastBuildDate><atom:link href="https://articles.maximemoreillon.com/tags/docker/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>User management and authentication service using MongoDB</title>
      <link>https://articles.maximemoreillon.com/articles/495/</link>
      <pubDate>Mon, 20 Sep 2021 00:00:00 +0000</pubDate>
      
      <guid>https://articles.maximemoreillon.com/articles/495/</guid>
      
      <description>&lt;p&gt;More often than not, web applications require restrictions regarding who can access the content that they serve. This involves an user management and authentication system, which, if designed inappropriately, can lead to security concerns. However, the development of such system can be time consuming, especially if done repeatedly for multiple applications.&lt;/p&gt;
&lt;p&gt;To solve this problem, this article presents a user management and authentication service, built around MongoDB, that can be easily plugged into an existing application with only minimal refactoring.&lt;/p&gt;</description>
      
    </item>
    
    <item>
      <title>Node.js DevOps example</title>
      <link>https://articles.maximemoreillon.com/articles/98/</link>
      <pubDate>Mon, 25 May 2020 00:00:00 +0000</pubDate>
      
      <guid>https://articles.maximemoreillon.com/articles/98/</guid>
      
      <description>&lt;p&gt;In this article, we’ll build a simple &lt;a href=&#34;https://nodejs.org/en/&#34;&gt;Node.js&lt;/a&gt; application that uses &lt;a href=&#34;https://expressjs.com/&#34;&gt;Express&lt;/a&gt; to respond to HTTP requests. In order to deploy this application to production, we’ll also configure a &lt;a href=&#34;https://docs.gitlab.com/ee/ci/&#34;&gt;GitLab CI/CD&lt;/a&gt; pipeline so as to &lt;a href=&#34;https://www.docker.com/&#34;&gt;dockerize&lt;/a&gt; it and deploy its container to a &lt;a href=&#34;https://kubernetes.io/&#34;&gt;Kubernetes&lt;/a&gt; cluster.&lt;/p&gt;
&lt;h2 id=&#34;prerequisites&#34;&gt;Prerequisites&lt;/h2&gt;
&lt;p&gt;This article assumes that the following environment is available to the reader:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;A development environment with &lt;a href=&#34;https://nodejs.org/en/&#34;&gt;Node.js&lt;/a&gt; installed.&lt;/li&gt;
&lt;li&gt;A &lt;a href=&#34;https://about.gitlab.com/install/&#34;&gt;GitLab&lt;/a&gt; instance with an available &lt;a href=&#34;https://docs.gitlab.com/runner/install/&#34;&gt;runner&lt;/a&gt; able to run the &lt;em&gt;docker&lt;/em&gt; and &lt;em&gt;kubectl&lt;/em&gt; commands.&lt;/li&gt;
&lt;li&gt;A production environment with a Kubernetes cluster reachable from the GitLab instance. For this, &lt;a href=&#34;https://microk8s.io/&#34;&gt;Microk8s&lt;/a&gt; is easy to get started with&lt;/li&gt;
&lt;li&gt;A &lt;a href=&#34;https://docs.docker.com/registry/deploying/&#34;&gt;Docker registry&lt;/a&gt; to push and pull containers to and from. Note that running your own registry might require &lt;a href=&#34;https://docs.docker.com/registry/insecure/&#34;&gt;Docker&lt;/a&gt; and Kubernetes configuration (guide for MicroK8s available &lt;a href=&#34;https://microk8s.io/docs/registry-private&#34;&gt;here&lt;/a&gt;)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Node.js application&lt;/p&gt;</description>
      
    </item>
    
    <item>
      <title>Application containerization</title>
      <link>https://articles.maximemoreillon.com/articles/445/</link>
      <pubDate>Thu, 21 May 2020 00:00:00 +0000</pubDate>
      
      <guid>https://articles.maximemoreillon.com/articles/445/</guid>
      
      <description>&lt;p&gt;Let&amp;rsquo;s imagine a developer building an application on his computer and that this application is meant to be deployed on a different machine (production environment). In order to execute properly, this application requires multiple libraries, binaries and packages. For example, a Python program requires the Python interpreter as well as all the imported Python modules.&lt;/p&gt;
&lt;p&gt;Thus, if the application is unlikely to run properly in the production environment if it is being deployed by simply copying its source code over.&lt;/p&gt;</description>
      
    </item>
    
    <item>
      <title>Creating a private docker registry for Kubernetes</title>
      <link>https://articles.maximemoreillon.com/articles/421/</link>
      <pubDate>Thu, 23 Apr 2020 00:00:00 +0000</pubDate>
      
      <guid>https://articles.maximemoreillon.com/articles/421/</guid>
      
      <description>&lt;p&gt;A docker registry can be run easily using as a docker container using docker itself.&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;docker run -d -p 5000:5000 --restart=always --name registry registry:2
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;However, this registry is accessed through HTTP and does not provide any authentication mechanism&lt;/p&gt;
&lt;p&gt;To solve this problem, the docker registry can be made so as to be accessed via an Ingress with Basic Authentication:&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;kind: Service
apiVersion: v1
metadata:
 name: registry
spec:
 type: ClusterIP
 ports:
 - port: 5000
   targetPort: 5000
---
kind: Endpoints
apiVersion: v1
metadata:
 name: registry
subsets:
 - addresses:
     - ip: 192.168.1.2
   ports:
     - port: 5000
---
apiVersion: extensions/v1beta1
kind: Ingress
metadata:
  name: registry
  annotations:
    kubernetes.io/ingress.class: &amp;#34;nginx&amp;#34;

    # Necessary to prevent 413 errors
    nginx.ingress.kubernetes.io/proxy-body-size: &amp;#34;500m&amp;#34;
    nginx/client_max_body_size: 500m

    cert-manager.io/cluster-issuer: &amp;#34;letsencrypt-prod&amp;#34;
    
    nginx.ingress.kubernetes.io/auth-type: basic
    nginx.ingress.kubernetes.io/auth-secret: registry
    nginx.ingress.kubernetes.io/auth-realm: &amp;#39;Authentication Required&amp;#39;
spec:
  tls:
  - hosts:
    - registry.example.com
    secretName: registry
  rules:
  - host: registry.example.com
    http:
      paths:
      - path: /
        backend:
          serviceName: registry
          servicePort: 5000
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Here, it is important to specify the maximum body size in the Ingress annotations to prevent 413 Request Entity Too Large errors&lt;/p&gt;</description>
      
    </item>
    
    <item>
      <title>Docker images and containers management</title>
      <link>https://articles.maximemoreillon.com/articles/35/</link>
      <pubDate>Fri, 06 Mar 2020 00:00:00 +0000</pubDate>
      
      <guid>https://articles.maximemoreillon.com/articles/35/</guid>
      
      <description>&lt;p&gt;Here are a few commands to manage docker images and containers&lt;/p&gt;
&lt;h2 id=&#34;images&#34;&gt;Images&lt;/h2&gt;
&lt;p&gt;List all images:&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;docker image ls -a
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Delete an image:&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;docker image rm IMAGE_NAME
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;containers&#34;&gt;Containers&lt;/h2&gt;
&lt;p&gt;Run a container:&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;docker run IMAGE_NAME
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Here, the container will run in the foreground with a randomly assigned name&lt;/p&gt;
&lt;p&gt;Run a container in the background:&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;docker run -d IMAGE_NAME
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Run a container and give it a certain name:&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;docker run -n CONTAINER_NAME IMAGE_NAME
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Stop a container (gracefully):&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;docker stop CONTAINER_NAME
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Kill a container (ungraceful stop):&lt;/p&gt;</description>
      
    </item>
    
    <item>
      <title>Docker restart container when docker restarts</title>
      <link>https://articles.maximemoreillon.com/articles/303/</link>
      <pubDate>Sat, 01 Feb 2020 00:00:00 +0000</pubDate>
      
      <guid>https://articles.maximemoreillon.com/articles/303/</guid>
      
      <description>&lt;p&gt;Simply add the following flag when using docker run&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;  --restart=always
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;If the container is already running:&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;docker update --restart=always &amp;lt;container&amp;gt;
&lt;/code&gt;&lt;/pre&gt;</description>
      
    </item>
    
    <item>
      <title>Gitlab CI commands for TF serving</title>
      <link>https://articles.maximemoreillon.com/articles/302/</link>
      <pubDate>Thu, 30 Jan 2020 00:00:00 +0000</pubDate>
      
      <guid>https://articles.maximemoreillon.com/articles/302/</guid>
      
      <description>&lt;p&gt;This is an example .gitlab-ci.yml file which can be used to containerize and deploy a tensorflow model&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;stages:
  - containerize
  - deploy

variables:
  SERVING_CONTAINER: serving_base
  DOCKER_IMAGE: 192.168.1.2:5000/redblack
  AI_MODEL: redblack
  DEPLOYMENT: redblack

containerization:
  stage: containerize
  script:
    # Run an empty tensorflow serving container
    - docker run -d --name ${SERVING_CONTAINER} tensorflow/serving
    # Copy the model into the serving container and save it as a new image
    - docker cp ./${AI_MODEL} ${SERVING_CONTAINER}:/models/${AI_MODEL}
    - docker commit --change &amp;#34;ENV MODEL_NAME ${AI_MODEL}&amp;#34; serving_base ${DOCKER_IMAGE}
    # Push the container to the registry
    - docker push ${DOCKER_IMAGE}
    # Cleanup
    - docker stop ${SERVING_CONTAINER}
    - docker container rm ${SERVING_CONTAINER}
    - docker image rm ${DOCKER_IMAGE}

deployment:
  stage: deploy
  script:
    - kubectl apply -f deployment.yml
    - kubectl rollout restart deployment/${DEPLOYMENT}
  environment:
    name: staging
&lt;/code&gt;&lt;/pre&gt;</description>
      
    </item>
    
    <item>
      <title>Serving a Keras model using Tensorflow serving and Docker</title>
      <link>https://articles.maximemoreillon.com/articles/297/</link>
      <pubDate>Wed, 29 Jan 2020 00:00:00 +0000</pubDate>
      
      <guid>https://articles.maximemoreillon.com/articles/297/</guid>
      
      <description>&lt;p&gt;A Keras model can be created in various ways, for example using the &lt;a href=&#34;https://keras.io/getting-started/sequential-model-guide/&#34;&gt;sequential model&lt;/a&gt;:&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;from keras.models import Sequential
from keras.layers import Dense, Activation

model = Sequential([
    Dense(32, input_shape=(784,)),
    Activation(&amp;#39;relu&amp;#39;),
    Dense(10),
    Activation(&amp;#39;softmax&amp;#39;),
])
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Such model can be saved using the save() function:&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;model.save(&amp;#39;./my_model/1&amp;#39;)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Here, the /1 at the end of the path is important for later.&lt;/p&gt;
&lt;p&gt;The model will be run inside a docker container. To do so, first download and run an &amp;ldquo;empty&amp;rdquo; serving container which will serve as a base:&lt;/p&gt;</description>
      
    </item>
    
    <item>
      <title>Minikube using insecure registry</title>
      <link>https://articles.maximemoreillon.com/articles/360/</link>
      <pubDate>Tue, 14 Jan 2020 00:00:00 +0000</pubDate>
      
      <guid>https://articles.maximemoreillon.com/articles/360/</guid>
      
      <description>&lt;p&gt;By default, Minikube will not allow the usage of insecure docker registries. To change this setting, Minikube can be started as so:&lt;/p&gt;
&lt;p&gt;Argument &amp;ndash;insecure registry can be used&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;minikube start --insecure-registry=&amp;#34;http://192.168.1.2:5000&amp;#34;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Here, replace http://192.168.1.2 with the URL of the registry&lt;/p&gt;
&lt;p&gt;For bare-metal (requires sudo):&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;sudo minikube start --insecure-registry=&amp;#34;http://192.168.1.2:5000&amp;#34; --vm-driver=none
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Note: if Minikube had already been started without the insecure-registry option, it must be stopped and recreated:&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;minikube stop
minikube delete
&lt;/code&gt;&lt;/pre&gt;</description>
      
    </item>
    
    <item>
      <title>Docker behind a proxy</title>
      <link>https://articles.maximemoreillon.com/articles/352/</link>
      <pubDate>Fri, 10 Jan 2020 00:00:00 +0000</pubDate>
      
      <guid>https://articles.maximemoreillon.com/articles/352/</guid>
      
      <description>&lt;p&gt;Docker does not use environment variables for proxy configuration. This article presents how to configure Docker to use a proxy.&lt;/p&gt;
&lt;p&gt;To use docker behind a proxy, create the file&lt;code&gt;/etc/systemd/system/docker.service.d/http-proxy.conf&lt;/code&gt; With the following content:&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;[Service]
Environment=&amp;#34;HTTP_PROXY=http://127.0.0.1:8118/&amp;#34;
Environment=&amp;#34;HTTPS_PROXY=http://127.0.0.1:8118/&amp;#34;
Environment=&amp;#34;NO_PROXY=localhost,127.0.0.1,172.16.98.151&amp;#34;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Here, &lt;code&gt;127.0.0.1:8118&lt;/code&gt; should be replaced by the address of your proxy&lt;/p&gt;
&lt;p&gt;Once done, reload the daemon and restart docker&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;sudo systemctl daemon-reload
sudo systemctl restart docker
&lt;/code&gt;&lt;/pre&gt;</description>
      
    </item>
    
    <item>
      <title>Docker HTTP (insecure) registry</title>
      <link>https://articles.maximemoreillon.com/articles/353/</link>
      <pubDate>Fri, 10 Jan 2020 00:00:00 +0000</pubDate>
      
      <guid>https://articles.maximemoreillon.com/articles/353/</guid>
      
      <description>&lt;p&gt;By default Docker refuses to push/pull from registries that are not served using HTTPS.&lt;/p&gt;
&lt;p&gt;To enable Docker to push to registries served over HTTP, the address of the registry must be appended to the &lt;code&gt;insecure-registries&lt;/code&gt; Array of the &lt;code&gt;/etc/docker/daemon.json&lt;/code&gt; file. If the file does not exist, it must be created.&lt;/p&gt;
&lt;p&gt;Here is an example:&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;{
  &amp;#34;insecure-registries&amp;#34; : [&amp;#34;IP:PORT&amp;#34;]
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Docker must be restarted after changes to &lt;code&gt;/etc/docker/daemon.json&lt;/code&gt; have been done:&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;sudo systemctl restart docker
&lt;/code&gt;&lt;/pre&gt;</description>
      
    </item>
    
    <item>
      <title>Self hosted Docker registry</title>
      <link>https://articles.maximemoreillon.com/articles/351/</link>
      <pubDate>Fri, 10 Jan 2020 00:00:00 +0000</pubDate>
      
      <guid>https://articles.maximemoreillon.com/articles/351/</guid>
      
      <description>&lt;p&gt;When using the &lt;code&gt;docker pull&lt;/code&gt; command, container images are by default downloaded from docker hub, the official public registry for container images. However, for some projects, images are better stored on a private platform. This can be achieved by hosting one&amp;rsquo;s own docker registry.&lt;/p&gt;
&lt;p&gt;A complete guide is written here: &lt;a href=&#34;https://docs.docker.com/registry/deploying/&#34;&gt;https://docs.docker.com/registry/deploying/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;This article merely summarizes the basics involved in the process.&lt;/p&gt;
&lt;h2 id=&#34;self-hosted-docker-registry-as-container&#34;&gt;Self hosted Docker registry as container&lt;/h2&gt;
&lt;p&gt;A docker registry is an application juste like any other and can this be containerized. In fact, an official image is available on docker hub. It can be run as so:&lt;/p&gt;</description>
      
    </item>
    
    <item>
      <title>NodeJS app dockerization</title>
      <link>https://articles.maximemoreillon.com/articles/343/</link>
      <pubDate>Thu, 09 Jan 2020 00:00:00 +0000</pubDate>
      
      <guid>https://articles.maximemoreillon.com/articles/343/</guid>
      
      <description>&lt;p&gt;NodeJS apps can be containerized using the &lt;code&gt;docker build&lt;/code&gt; command. This article is based on &lt;a href=&#34;https://nodejs.org/de/docs/guides/nodejs-docker-webapp/&#34;&gt;this guide&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;To create a container image, a Dockerfile is needed. Here is an example specifically made for the containerization of NodeJS apps:&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;FROM node:14

# Create and move into app directory
WORKDIR /usr/src/app

# Copy files of host current workdir
# into container workdir
COPY . .

# Install dependecies described in packages.json
RUN npm install

# Open port 8080
EXPOSE 8080

# Run the node app
CMD [ &amp;#34;node&amp;#34;, &amp;#34;server.js&amp;#34; ]
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;RUN is for commands to be executed during the container building process&lt;/p&gt;</description>
      
    </item>
    
  </channel>
</rss>
