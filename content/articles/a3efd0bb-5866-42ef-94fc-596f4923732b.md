+++
date = '2023-02-21'
title = "Kubernetes and Docker equivalence"
tags = ['Kubernetes', 'Tutorials']
+++

Kubernetes is a container orchestration system. As such, it features functions that are similar to that of Docker. If a container can be run with the Docker CLI, it can also be run equivalently using Kubernetes. This articles highlights such equivalence by presenting how to deploy a PostgreSQL instance using both technologies.

Docker
------

Running a PostgreSQL container usually involves the configuration of its environment variables, persistent volumes and port forwarding. With the `docker run` command, those are set using the -e, -v and -p flags respectively. The `docker run` command also expects the container image to be specified as last argument. As such, running a PostgreSQL instance can be achieved using:

![Article image](https://img.maximemoreillon.com/images/63f43a594417694465b84957)

Kubernetes
----------

When using Kubernetes, containers can be run by using manifests, which contain specifications of the resources need for its operations. In the case of PostgreSQL, three resources are necessary: A deployment, service and persistent volume claim.

The deployment mainly specifies what container is to be run as well as its environment variables and volume mounts. The service handles networking. In this case, it ensures the container is accessible using the chosen port. Finally, the persistent volume claim is used to allocate a persistent volume for the chosen volume mounts.

As such, the equivalent Kubernetes manifest for the `docker run` command here above becomes:

![Article image](https://img.maximemoreillon.com/images/63f43c46441769b69db8495b)

Such manifest is obviously much more complex than the docker command here above. However, it is important to keep in mind that such complexity is the result of having much more customization options. For instance, containers managed by Kubernetes can be configured to be automatically replicated to accommodate larger request volumes. On the other hand, docker commands can quickly become tedious to write when the parameter count increases or when dealing with multiple containers that need to be connected to each other.